<div id='content'>
  <button id="nav-toggle">nav</button>
  <div id="sidebar">
    <div id="cityMenu" class="menu">
      <h3 class="menuHeader">Select your City</h3>
      <div data-bind="foreach:cities">
        <div class=option>
          <p data-bind="text: name, click: $root.goToRequestTypeMenu"></p>
        </div>
      </div>
    </div>
    <div id="requestTypeMenu" class="menu">
      <button data-bind="click: goToCityMenu"><</button>
      <h3 class="menuHeader">Select a Request Type</h3>
      <div data-bind="foreach:requestTypes">
        <div class="option">
          <p data-bind="text: name, click: $root.goToClusterMenu"></p>
        </div>
      </div>
    </div>
    <div id="clusterMenu" class="menu">
      <button data-bind="click: goToRequestTypeMenu"><</button>
      <h3 class="menuHeader">Select a cluster<h3>
      <div  data-bind="foreach: clusters">
        <p data-bind="text: score"></p>
        <div class="option" data-bind="foreach: street_names, click: $root.goToClusterView">
          <p data-bind="text: name"></p>
        </div>
      </div>
    </div>
  </div>
  <div id="map"></div>
  <!-- <div id="issueMenu" data-bind="foreach: issues">
    <div class="option bottom-option">
      <p data-bind="text: 'qwer'">
    </div>
  </div> -->
</div>

<!-- Menu toggles and UI changeing features -->
<script>
  $("#nav-toggle").click(function(e){
    $("#nav").toggleClass("open");
  });
</script>


<!--Knockout.js and Sammy Based UI-->
<!--Note: UI script must be placed below html to work-->
<script>
  function ClusterViewModel(){
    var self = this;
    // Observables
    // order of observable declaration reflects
    // the flow of selection in the UI
    self.cities = ko.observable();
    self.chosenCityId = ko.observable();
    self.requestTypes = ko.observable();
    self.chosenRequestTypeId = ko.observable();
    self.clusters = ko.observable();
    self.chosenClusterId = ko.observable();
    self.issues = ko.observable();

    //Behaviors
    // order of behaviors reflects
    // the flow of selection in the UI
    self.goToCityMenu = function(){
      location.hash = "/city_menu/"
    }
    self.goToRequestTypeMenu = function(city) {
      location.hash = "/request_type_menu/"+city.id_+"/"
    };
    self.goToClusterMenu = function(request_type){
      location.hash = "/cluster_menu/"+request_type.id_+"/"
    };
    self.goToClusterView = function(cluster){
      location.hash = "/cluster_view/"+cluster.id_+"/"
      console.log(cluster.score);
    }

    //Routing using Sammy
    //once again, order reflect flow
    // of selection in the UI
    Sammy(function(){
      this.get('/#/city_menu/',function(){
        $("#requestTypeMenu").hide();
        $("#clusterMenu").hide();
        $("#issueMenu").hide();
        $("#cityMenu").show();
        $.get('/clusters/city_menu/',
          function(data){self.cities(data["cities"]);
        });
      });

      this.get('/#/request_type_menu/:city_id/', function(){
        $("#cityMenu").hide();
        $("#clusterMenu").hide();
        $("#issueMenu").hide();
        $("#requestTypeMenu").show();
        // update observables only if we are coming from previous menu
        if(this.params.city_id!="undefined"){
          $.get('/clusters/request_type_menu/'+this.params.city_id,
            function(data){
              self.requestTypes(data["request_types"]);
              $("#map").ready(function(){
                newMap(
                  {"lat": data["city"]["lat"],
                  "lng": data["city"]["lng"]});
              });
          });
          self.chosenCityId(this.params.city_id);
        }
      });

      this.get('/#/cluster_menu/:request_type_id/', function(){
        $("#cityMenu").hide();
        $("#requestTypeMenu").hide();
        $("#issueMenu").hide();
        $("#clusterMenu").show();
        //update observables only if we are coming from previous menu
        if(this.params.request_type_id!="undefined"){
          $.get('/clusters/cluster_menu/'+this.params.request_type_id,
            function(data){
              self.clusters(data["clusters"]);
              plotMap(data["issues"],null);
          });
          self.chosenRequestTypeId(this.params.request_type_id);
        }
      });
      this.get('/#/cluster_view/:cluster_id/',function(){
        self.chosenClusterId(this.params.cluster_id);
        $("#cityMenu").hide();
        $("#requestTypeMenu").hide();
        $("#clusterMenu").show();
        $("#issueMenu").show();
        $.get('/clusters/'+this.params.cluster_id,
          function(data){
            self.issues(data["issues"]);
            updateMap(data["issues"]);
        })
      });

    }).run();


    this.goToCityMenu()
  }

  ko.applyBindings(new ClusterViewModel());
</script>

<!--google maps api code-->
<script>
  var map;
  var markers =[];

  function newMap(city_coords){
    // Create a map object and specify the DOM element for display.
    map = new google.maps.Map(document.getElementById('map'), {
      center: city_coords,
      scrollwheel: false,
      zoom:8
    });
  };

  function plotMap(issues){
    // create new latlngbounds object
    // which we will use to center and focus the map
    var latlngbounds = new google.maps.LatLngBounds();

    //iterate over issues populating the map and the bounds
    issues.forEach(function(issue){
      var loc = new google.maps.LatLng(issue.lat,issue.lng);
      latlngbounds.extend(loc);
      markers.push(
        new google.maps.Marker({
          sName:issue["id_"],
          position: loc,
          map: map,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillOpacity: 0.1,
            fillColor: "blue",
            strokeOpacity: 0.5,
            strokeWeight: 1.0,
            scale: 10 //pixels
          }
        })
      );
    });

    //map.setCenter(latlngbounds.getCenter());
    map.fitBounds(latlngbounds);
  };

  function updateMap(issues){
    // create new latlngbounds object
    // which we will use to center and focus the map
    var latlngbounds = new google.maps.LatLngBounds();

    issue_ids = issues.map(function(issue){
      return issue.id_;
    });

    markers.forEach(function(marker){
      console.log(issue_ids);
      console.log(marker.sName);
      if (issue_ids.indexOf(marker.sName)>0){
        console.log("red");
        color="red";
      }else{
        color="blue";
      };
      marker.setIcon({
        path: google.maps.SymbolPath.CIRCLE,
        fillOpacity: 0.5,
        fillColor: color,
        strokeOpacity: 0.5,
        strokeWeight: 1.0,
        scale: 10
      });
    });

    issues.forEach(function(issue){
      var loc = new google.maps.LatLng(issue.lat,issue.lng);
      latlngbounds.extend(loc);
    });

    map.fitBounds(latlngbounds);
  }

</script>
